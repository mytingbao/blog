---
layout: post
title: C语言笔记02
date: 2022-07-20 08:09:50 +0300
img: 17.jpg
tags: [CLang, Study]
author: fangfang
description: 接上篇
---

# 指针
## 简介
指针是什么？
首先，它是一个值，这个值代表一个内存地址，因此指针相当于指向某个内存地址的路标。
> 这里对于我们有JS经验的人来说，应该不难理解。就跟JS中的复杂数据类型一样，
比如声明一个数组时，其实执行了两件事，一是在堆中存储了数据，二是声明了一个变量指向这个堆中的数据，这个变量就是指针。

字符*表示指针，通常跟在类型关键字的后面，表示指针指向的是什么类型的值。比如，char*表示一个指向字符的指针，float*表示一个指向float类型的值的指针。

```c
int* intPtr;
```

上面示例声明了一个变量intPtr，它是一个指针，指向的内存地址存放的是一个整数。
星号*可以放在变量名与类型关键字之间的任何地方，下面的写法都是有效的。

```c
int   *intPtr;
int * intPtr;
int*  intPtr;
```

这种写法有一个地方需要注意，如果同一行声明两个指针变量，那么需要写成下面这样。

```c
// 正确
int * foo, * bar;

// 错误
int* foo, bar;
```

上面示例中，第二行的执行结果是，foo是整数指针变量，而bar是整数变量，即*只对第一个变量生效。
一个指针指向的可能还是指针，这时就要用两个星号**表示。

```c
int** foo;
```
上面示例表示变量foo是一个指针，指向的还是一个指针，第二个指针指向的则是一个整数。


## * 运算符
*这个符号除了表示指针以外，还可以作为运算符，用来取出指针变量所指向的内存地址里面的值。

```c
void increment(int* p) {
  *p = *p + 1;
}
```
*上面示例中，函数increment()的参数是一个整数指针p。函数体里面，*p就表示指针p所指向的那个值。对*p赋值，就表示改变指针所指向的那个地址里面的值。*

上面函数的作用是将参数值加1。该函数没有返回值，因为传入的是地址，函数体内部对该地址包含的值的操作，会影响到函数外部，所以不需要返回值。
事实上，函数内部通过指针，将值传到外部，是 C 语言的常用方法。

变量地址而不是变量值传入函数，还有一个好处。对于需要大量存储空间的大型变量，复制变量值传入函数，非常浪费时间和空间，不如传入指针来得高效。

## & 运算符

> &运算符用来取出一个变量所在的内存地址。

```c
int x = 1;
printf("x's address is %p\n", &x);
```

上面示例中，x是一个整数变量，&x就是x的值所在的内存地址。printf()的%p是内存地址的占位符，可以打印出内存地址。

上一小节中，参数变量加1的函数，可以像下面这样使用。

```c
void increment(int* p) {
  *p = *p + 1;
}

int x = 1;
increment(&x);
printf("%d\n", x); // 2
```
上面示例中，调用increment()函数以后，变量x的值就增加了1，原因就在于传入函数的是变量x的地址&x。

> &运算符与*运算符互为逆运算，下面的表达式总是成立。

```c
int i = 5;

if (i == *(&i)) // 正确
```





# 函数
## 简介
和js中的函数相比较，C语言中的函数存在以下几点不同
* 不需要function关键字声明
* 函数调用时，参数个数必须与定义里面的参数个数一致
* 函数必须先声明后调用（不存在hoist）
* 实参和形参的类型不一致时，会自动转换为形参类型
* 如果没有写返回值类型，默认是int

```c
int plus_one(int n) {
  return n + 1;
}
```
上面的代码声明了一个函数plus_one()。

函数调用时，参数个数必须与定义里面的参数个数一致，参数过多或过少都会报错。

```c
int plus_one(int n) {
  return n + 1;
}

plus_one(2, 2); // 报错
plus_one();  // 报错
```
上面示例中，函数plus_one()只能接受一个参数，传入两个参数或不传参数，都会报错。

```c
int a = plus_one(13);

int plus_one(int n) {
  return n + 1;
}
```
上面示例中，在调用plus_one()之后，才声明这个函数，编译就会报错。

```c
#include <stdio.h>
int main(void)
{
    void change2(double num1, double num2)
    {
        printf("num1 = %.1f\n", num1);
        printf("num2 = %f", num2);
    }
    change2(1.2, 3);
}

```
上面示例中，自动将实参转为double后保存

## main方法

C 语言规定，main()是程序的入口函数，即所有的程序一定要包含一个main()函数。程序总是从这个函数开始执行，如果没有该函数，程序就无法启动。其他函数都是通过它引入程序的。

main()的写法与其他函数一样，要给出返回值的类型和参数的类型，就像下面这样。
```c
int main(void) {
  printf("Hello World\n");
  return 0;
}

```
上面示例中，最后的return 0;表示函数结束运行，返回0。

C 语言约定，返回值0表示函数运行成功，如果返回其他非零整数，就表示运行失败，代码出了问题。系统根据main()的返回值，作为整个程序的返回值，确定程序是否运行成功。

正常情况下，如果main()里面省略return 0这一行，编译器会自动加上，即main()的默认返回值为0。所以，写成下面这样，效果完全一样。

```c
int main(void) {
  printf("Hello World\n");
}
```
> 由于 C 语言只会对main()函数默认添加返回值，对其他函数不会这样做，所以建议总是保留return语句，以便形成统一的代码风格。

系统在程序启动调用main函数会传入以下两个参数

* 参数个数
* 每个参数组成的数组，第一个参数总是main函数执行文件的路径，剩余参数皆为执行时传入的参数

```c
#include <stdio.h>
int main(int argc, const char *argv[])
{
    printf("argc = %d\n", argc);
    printf("argv [0] pwd= %s\n", argv[0]);
    printf("argv [1] args%s\n", argv[1]);
};
```

## 函数原型

前面说过，函数必须先声明，后使用。由于程序总是先运行main()函数，导致所有其他函数都必须在main()函数之前声明。

但是，main()是整个程序的入口，也是主要逻辑，放在最前面比较好。另一方面，对于函数较多的程序，保证每个函数的顺序正确，会变得很麻烦。

> C 语言提供的解决方法是，只要在程序开头处给出函数原型，函数就可以先使用、后声明。所谓函数原型，就是提前告诉编译器，每个函数的返回类型和参数类型。其他信息都不需要，也不用包括函数体，具体的函数实现可以后面再补上。

```c
int twice(int);

int main(int num) {
  return twice(num);
}

int twice(int num) {
  return 2 * num;
}
```
上面示例中，函数twice()的实现是放在main()后面，但是代码头部先给出了函数原型，所以可以正确编译。只要提前给出函数原型，函数具体的实现放在哪里，就不重要了。

函数原型包括参数名也可以，虽然这样对于编译器是多余的，但是阅读代码的时候，可能有助于理解函数的意图。
```c
int twice(int);

// 等同于
int twice(int num);
```

上面示例中，twice函数的参数名num，无论是否出现在原型里面，都是可以的。

注意，函数原型必须以分号结尾。

一般来说，每个源码文件的头部，都会给出当前脚本使用的所有函数的原型。

## exit

exit()函数用来终止整个程序的运行。一旦执行到该函数，程序就会立即结束。该函数的原型定义在头文件stdlib.h里面。

exit()可以向程序外部返回一个值，它的参数就是程序的返回值。一般来说，使用两个常量作为它的参数：EXIT_SUCCESS（相当于 0）表示程序运行成功，EXIT_FAILURE（相当于 1）表示程序异常中止。这两个常数也是定义在stdlib.h里面。

```c
// 程序运行成功
// 等同于 exit(0);
exit(EXIT_SUCCESS);

// 程序异常中止
// 等同于 exit(1);
exit(EXIT_FAILURE);
```

在main()函数里面，exit()等价于使用return语句。其他函数使用exit()，就是终止整个程序的运行，没有其他作用。

C 语言还提供了一个atexit()函数，用来登记exit()执行时额外执行的函数，用来做一些退出程序时的收尾工作。该函数的原型也是定义在头文件stdlib.h。

```c
int atexit(void (*func)(void));
```

atexit()的参数是一个函数指针。注意，它的参数函数（下例的print）不能接受参数，也不能有返回值。

```c
#include <stdio.h>
#include <stdlib.h>
int main(void)
{
    void print(void) { printf("somethig run while exit!"); };
    atexit(print);
    exit(EXIT_FAILURE);
}
```
上面示例中，exit()执行时会先自动调用atexit()注册的print()函数，然后再终止程序。

## 函数说明符
### extern 说明符

对于多文件的项目，源码文件会用到其他文件声明的函数。这时，当前文件里面，需要给出外部函数的原型，并用extern说明该函数的定义来自其他文件。

```c
extern int foo(int arg1, char arg2);

int main(void) {
  int a = foo(2, 3);
  // ...
  return 0;
}
```

上面示例中，函数foo()定义在其他文件，extern告诉编译器当前文件不包含该函数的定义。

不过，由于函数原型默认就是extern，所以这里不加extern，效果是一样的。

### static 说明符

默认情况下，每次调用函数时，函数的内部变量都会重新初始化，不会保留上一次运行的值。static说明符可以改变这种行为。

static用于函数内部声明变量时，表示该变量只需要初始化一次，不需要在每次调用时都进行初始化。也就是说，它的值在两次调用之间保持不变。

```c
#include <stdio.h>

void counter(void) {
  static int count = 1;  // 只初始化一次
  printf("%d\n", count);
  count++;
}

int main(void) {
  counter();  // 1
  counter();  // 2
  counter();  // 3
  counter();  // 4
}
```

上面示例中，函数counter()的内部变量count，使用static说明符修饰，表明这个变量只初始化一次，以后每次调用时都会使用上一次的值，造成递增的效果。

注意，static修饰的变量初始化时，只能赋值为常量，不能赋值为变量。


```c
int i = 3;
static int j = i; // 错误
```
上面示例中，j属于静态变量，初始化时不能赋值为另一个变量i。

另外，在块作用域中，static声明的变量有默认值0。
```c
static int foo;
// 等同于
static int foo = 0;
```

static可以用来修饰函数本身。

```c
static int Twice(int num) {
  int result = num * 2;
  return(result);
}
```

上面示例中，static关键字表示该函数只能在当前文件里使用，如果没有这个关键字，其他文件也可以使用这个函数（通过声明函数原型）。

static也可以用在参数里面，修饰参数数组。

```c
int sum_array(int a[static 3], int n) {
  // ...
}
```

上面示例中，static对程序行为不会有任何影响，只是用来告诉编译器，该数组长度至少为3，某些情况下可以加快程序运行速度。
另外，需要注意的是，对于多维数组的参数，static仅可用于第一维的说明。


### const 说明符
函数参数里面的const说明符，表示函数内部不得修改该参数变量。
```c
void f(int* p) {
  // ...
}
```
上面示例中，函数f()的参数是一个指针p，函数内部可能会改掉它所指向的值*p，从而影响到函数外部。

为了避免这种情况，可以在声明函数时，在指针参数前面加上const说明符，告诉编译器，函数内部不能修改该参数所指向的值。

```c
void f(const int* p) {
  *p = 0; // 该行报错
}
```
上面示例中，声明函数时，const指定不能修改指针p指向的值，所以*p = 0就会报错。

但是上面这种写法，只限制修改p所指向的值，而p本身的地址是可以修改的。
```c
void f(const int* p) {
  int x = 13;
  p = &x; // 允许修改
}
```

上面示例中，p本身是可以修改，const只限定*p不能修改。

如果想限制修改p，可以把const放在p前面。

```c
void f(int* const p) {
  int x = 13;
  p = &x; // 该行报错
}
```
如果想同时限制修改p和*p，需要使用两个const。

```c
void f(const int* const p) {
  // ...
}
```




# 数组
# 内存管理
## 进程空间

* 程序，是经过源码编译后的可执行文件，可执行文件可以多次被执行，比如我可以多次打开谷歌浏览器
* 进程，是程序加载到内存后开始执行到执行结束，这样一段时间概念，多次打开谷歌浏览器，每打开一次都是一个进程，每当关闭一个浏览器，则表示该进程结束
* 程序是静态概念，而进程是动态/时间的概念

进程空间示意图
有个进程和空间的概念，程序被加载到内存后内存的空间布局是怎么样的：

![Flower and water]({{site.baseurl}}/images/post/202207/01.png)
