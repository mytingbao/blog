---
layout: post
title: C&C++查缺补漏
date: 2022-08-12 01:09:50 +0300
img: 21.webp
tags: [C&C++, Study,'2022']
author: Winston
description: C&C++查缺补漏
---

# 第一部分、数据类型

## 字符型
* C和C++中的字符型变量值占用一个字节
* 字符型变量并不是把字符本身存放到内存中存储，而是将对应的**ASCII编码放入存储单元**

# 第二部分、运算符

##  算术运算符

```cpp
// cout << "10/0=" << 10 / 0 << endl; // 报错 除数不能为 0 。
cout << "0.9 / 0.2 = " << 0.9 / 0.2 << endl; // 4.5
cout << "0.1 % 0.4 = " << 0.1 % 0.4 << endl; // 小数不能进行取模运算
// cout << "10%0 = " << 10 % 0 << endl; // 取模就是相除后取余数。既然相除都会报错，取模就更不用说了。
cout << "10%230 = " << 10 % 20 << endl; // 10
```
# 第三部分 指针

## 3.1 指针的定义和使用和所占的内存空间

```cpp

int a = 10;

// 1、指针定义的语法： 数据类型 * 指针变量名
int* p;
// 让指针记录变量a的地址
p = &a;
cout << "a的地址为" << &a <<  endl;
cout << "指针p的地址为" << p << endl;

// 2、解引用
// 可以通过解引用的方法来找到指针指向的内存
// 指针前加 * 代表解引用，找到指针指向的内存中的数据
cout << " *p = " << *p << endl;
*p = 1000;
cout << "after define a = " << a << endl;
cout << " *p = " << *p << endl;

// 3、 指针所占的内存空间
// 一个指针变量（不论什么类型）占4个字节、64位系统下占8个字节
cout << "sizeof (int *)= " << sizeof(int *) << endl;
cout << "sizeof (float *)= " << sizeof(float *) << endl;
cout << "sizeof (float *)= " << sizeof(double *) << endl;

```

## 3.2 空指针和野指针

```cpp
// 空指针用于给指针变量进行初始化
int* p = NULL;

// 空指针是不可以进行访问的
*p = 1000;  // 报错

```

```cpp
// 指针变量p指向内存地址编号为 0x1100的空间
int* p = (int*)0x1100;
// 访问野指针报错 (引发了异常: 读取访问权限冲突。)
cout << *p << endl;
```

> 空指针和野指针都不是我们申请的空间，不能随意访问


## 3.3 const修饰指针

```cpp
// 1、const 修饰指针 --- 常量指针
int a = 10;
int b = 20;
const int* p1 = &a;

// 指针的指向可以改，指针指向的值不可以改
p1 = &b;
*p1 = 100; //error

// 2、const 修饰常量 --- 指针常量
int* const p2 = &a;
// 指针的指向不可以改，指针指向的值可以改

p2 = &b;  //error
*p2 = 200;

```
> const 修饰指针,则指针不可以改，修饰变量，则变量不可以改


# 第四部分、结构体

## 4.1结构体数组
```cpp
struct Student {
	string name;
	int age;
	int score;
};
struct Student studentList[3] = {
	{"郑家崇",19,132},
	{"郑家崇1",12,142},
	{"郑家崇2",21,92}
};
cout << studentList[1].score << endl;
```

## 4.2结构体指针

```cpp
struct Student {
	string name;
	int age;
	int score;
};
struct Student stu = { "郑家崇",19,132 };

struct Student* p = &stu; 
// 声明一个结构体指针，指向某个结构体。
// 指针通过 -> 可以访问成语
cout << p->score << endl;
```

## 4.3 结构体中const使用场景（限定结构体中的成员不可变更）

```cpp
struct Student {
	string name;
	int age;
	int score;
};

// 结构体中const使用场景（限定结构体中的成员不可变更）
void changeName(const Student* s)
{
	s->name = "winston"; // 报错
	cout << s->name << endl;
};


int main(void) {
	struct Student stu = { "郑家崇",19,132 };
	struct Student* p = &stu; 
	changeName(&stu);
}

```

# 第五部分、程序的内存模型

 C++程序在执行时，将内存大方向划分为4个区域：

* 代码区：存放函数体的二进制代码．由操作系统进行管理的。
* 全局区：存放全局变量和静态变量以及常量。
* 栈区：由编译器自动分配释放，存放函数的参数值、局部变量等。
* 堆区：由程序员分配放．若程序员不释放，程序结束时由操作系统回收。

**内存四区的意义：**

不同区域存放的数据，赋予不同的生命周期，给我们最大的灵活编程。


## 5.1 程序运行后

**栈区：**
由编译器自动分配释放，存放函数的参数值，局部变量等。
注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放。

```cpp
int* fun() {
	int a = 10;
	return &a;
}
int main(void) {
	int* p = fun();
	cout << *p << endl;
	cout << *p << endl; // 函数执行完成之后会自动被回收，所以这里就变得无法访问了。
}
```
  
**堆区：**

由程序员分配释放，若程序员不释放，程序结束时由操作系统回收

在C++中主要利用new在堆区开辟内存

```cpp
int *p = new int(10); //new方法返回一个内存地址
```

# 第六部分、引用
## 基本语法

数据类型 &别名 = 原名

```cpp
int a = 10;
int &b = a;
b = 20;
cout << a << endl; // 20
```
## 引用的注意事项
* 必须要初始化

## 引用做为函数的参数

当我们试图去交换两个变量的时候，我们常用地址传递，当然我们现在可以使用引用传递。**引用会对实参进行修改**


{% highlight cpp %}

void swap(int& a, int& b) {
	int temp = a;
	a = b;
	b = temp;
};

int main(void) {
	int a = 10;
	int b = 30;
	swap(a, b);
	cout << "a=" << a << endl; // 30
	cout << "b=" << b << endl;
}

{% endhighlight %}

## 常量引用

{% highlight cpp %}
void change(const int& a) {
	a = 12;
};

int main(void) {
	int a = 10;
	change(a);
	cout << "a=" << a << endl; 
	
}
{% endhighlight %}

防止在函数中操作影响实参

# 第七部分 函数高级

## 7.1 注意事项

* 如果函数声明中有默认参数，则**函数定义就不能重复定义默认参数**了。

## 7.2 函数重载的的注意事项
### 7.2.1 引用作为重载的条件

```cpp
void func(int& a) {
	cout << "func(int& a) 调用" << endl;
}
void func(const int& a) {
	cout << "func(const int& a) 调用" << endl;
}

int main(void) {
	int a = 10;
	func(a);
	func(10); // 整型常量
}
```
